#include "verilator.hpp"

#include <llvm/IR/DerivedTypes.h>

#include <boost/format.hpp>
#include <boost/range/irange.hpp>

#include <util/llvm_type.hpp>

namespace llpm {

static const char* globalOpts =
    "--cc --compiler clang --stats -O3";

void VerilatorWedge::writeModule(FileSet& fileset, Module* mod) {
    // Write verilog module
    FileSet::File* vModFile = fileset.create(mod->name() + ".v");
    _verilog->writeModule(vModFile, mod);

    // Run Verilator, creating several files
    std::string tmpdir = fileset.tmpdir();
    std::string command = str(
        boost::format("%1%/verilator/bin/verilator_bin %2% --Mdir %3% %4%")
            % Directories::executablePath()
            % globalOpts
            % tmpdir
            % vModFile->name()
            );
    printf("Running: %s\n", command.c_str());
    int rc = system(command.c_str());
    if (rc == -1)
        throw SysError("running verilator");

    vModFile->erase();

    FileSet::File* hpp = fileset.create(mod->name() + ".hpp");
    writeHeader(hpp, mod);
}

static const std::string HppHeader = R"STRING(
/*****************
 *  This code autogenerated by LLPM.
 *  DO NOT MODIFY MANUALLY!
 *  Manual changes will be overwritten.
 ******/

#include <stdint.h>

)STRING";

std::string typeSigPlain(llvm::Type* type, bool pointerize) {
    if (pointerize) {
        return typeSigPlain(type, false) + "*";
    }

    switch (type->getTypeID()) {
    case llvm::Type::IntegerTyID:
        if (type->getIntegerBitWidth() <= 8)
            return "uint8_t";
        if (type->getIntegerBitWidth() <= 16)
            return "uint16_t";       
        if (type->getIntegerBitWidth() <= 32)
            return "uint32_t";
        if (type->getIntegerBitWidth() <= 64)
            return "uint64_t";
        throw InvalidArgument("Error: cannot produce C++ header for integer type > 64 bits wide");
    case llvm::Type::HalfTyID:
            return "half";
    case llvm::Type::FloatTyID:
            return "float";
    case llvm::Type::DoubleTyID:
            return "double";
    case llvm::Type::X86_FP80TyID:
            return "_float128";
    case llvm::Type::StructTyID:
        {
            llvm::StructType* st = llvm::dyn_cast<llvm::StructType>(type);
            if (!st->hasName())
                throw InvalidArgument("Can only print struct signature if it has a name!");
            return st->getName();
        }
    default:
        throw InvalidArgument("Error: don't know how to print type: " + typestr(type));
    }

    return typestr(type);
}

std::string typeSig(llvm::Type* type, bool pointerize) {
    if (type->isStructTy()) {
        llvm::StructType* st = llvm::dyn_cast<llvm::StructType>(type);
        std::string sig = "\n";
        for (auto i: boost::irange<size_t>(0, st->getNumElements())) {
            sig = sig + "        " + typeSigPlain(st->getContainedType(i), pointerize) 
                  + (i == (st->getNumElements() - 1) ? "  // " : ", // ") + typestr(st->getContainedType(i)) + "\n";
        }
        return sig;
    }
    return typeSigPlain(type, pointerize);
}

void VerilatorWedge::writeHeader(FileSet::File* f, Module* mod) {
    ostream& os = f->openStream();
    os << HppHeader;

    os << "// Forward declaration for ugly verilator class\n";
    os << "class V" << mod->name() << ";\n";
    os << "\n";

    os << "/*\n"
       << " * This class is the wrapper for the " + mod->name() + " module.\n"
       << " */\n";


    os << "class " << mod->name() << " {\n";
    os << "public:\n";

    os << "    " << mod->name() << "();\n"
       << "\n";

    for (InputPort* ip: mod->inputs()) {
        os << "    // Input port '" << ip->name() << "'\n";
        auto sig = typeSig(ip->type(), false);
        os << boost::format("    bool %1%_nonblock(%2%    );\n")
                    % ip->name()
                    % sig;
        os << boost::format("    void %1%(%2%    );\n")
                    % ip->name()
                    % sig;
        os << "\n";
    }

    for (OutputPort* op: mod->outputs()) {
        os << "    // Output port '" << op->name() << "'\n";
        auto sig = typeSig(op->type(), true);
        os << boost::format("    bool %1%_nonblock(%2%    );\n")
                    % op->name()
                    % sig;
        os << boost::format("    void %1%(%2%    );\n")
                    % op->name()
                    % sig;
        os << "\n";
    }


    os << "    // Simulation run control\n"
       << "    void run(unsigned cycles = 1);\n";


    os << "\nprivate:\n";
    os << "    V" << mod->name() << "* simulator;\n";
    os << "};\n\n";

    f->close();
}

};

