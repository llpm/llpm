#include "scheduled_region.hpp"
#include <util/misc.hpp>
#include <libraries/synthesis/pipeline.hpp>

#include <boost/format.hpp>

using namespace std;

namespace llpm {

ScheduledRegionVerilogPrinter::ScheduledRegionVerilogPrinter(
        VerilogSynthesizer* parent,
        FileSet& dir,
        ScheduledRegion* sr) :
    _parent(parent),
    _sr(sr),
    _modFile(dir.create(sr->name() + ".sv")),
    _ctxt(_modFile->openStream(), sr)
    { }

ScheduledRegionVerilogPrinter::~ScheduledRegionVerilogPrinter() {
    _modFile->flush();
    _modFile->close();
}

void ScheduledRegionVerilogPrinter::writeRegion(
    std::set<FileSet::File*>& files) {
    files.insert(_modFile);

    writeHeader();
    writeIO();
    writeConstants();
    writeStartControl();
    for (unsigned i=0; i<_sr->cycles().size(); i++)
        writeCycle(i);
    writeOutputs();
    writeFooter();
}

static const std::string header = R"STRING(
/*****************
 *  This code autogenerated by LLPM.
 *  DO NOT MODIFY MANUALLY!
 *  Manual changes will be overwritten.
 ******/
`default_nettype none
)STRING";

void ScheduledRegionVerilogPrinter::writeHeader() {
    _ctxt << header;
    _ctxt << "\n\n";
    _ctxt << "// The \"" << _sr->name() << "\" Scheduled Region\n";
    _ctxt << "module " << _sr->name() << " (\n";

}

void ScheduledRegionVerilogPrinter::writeFooter() {
    _ctxt << "endmodule\n";
    _ctxt << "`default_nettype wire\n";
}

void ScheduledRegionVerilogPrinter::writeIO() {
    _ctxt << "// Real (external) inputs\n\n";
    for (auto&& ip: _sr->externalInputs()) {
        auto inputName = _ctxt.name(ip, true);
        auto width = bitwidth(ip->type());
        if (bitwidth(ip->type()) > 0)
            _ctxt << boost::format("    input wire [%1%:0] %2%, //Type: %3%\n")
                    % (width - 1)
                    % inputName
                    % typestr(ip->type());
        else
            _ctxt << boost::format("    // %1% Type: %2%\n")
                    % inputName 
                    % typestr(ip->type());
        _ctxt << boost::format("    input wire %1%_valid,\n") % inputName;
        _ctxt << boost::format("    output wire %1%_bp,\n") % inputName;
        _ctxt << "\n";
    }

    _ctxt << "// Real (external) outputs\n\n";
    for (auto&& op: _sr->externalOutputs()) {
        auto outputName = _ctxt.name(op, true);
        auto width = bitwidth(op->type());
        if (bitwidth(op->type()) > 0)
            _ctxt << boost::format("    output wire [%1%:0] %2%, //Type: %3%\n")
                    % (width - 1)
                    % outputName
                    % typestr(op->type());
        else
            _ctxt << boost::format("    // %1% Type: %2%\n")
                    % outputName
                    % typestr(op->type());
        _ctxt << boost::format("    output wire %1%_valid,\n") % outputName;
        _ctxt << boost::format("    input wire %1%_bp,\n") % outputName;
        _ctxt << "\n";
    }

    _ctxt << "// Virtual (internal) inputs\n\n";
    for (auto&& ip: _sr->internalInputs()) {
        auto inputName = _ctxt.name(ip, true);
        auto width = bitwidth(ip->type());
        if (bitwidth(ip->type()) > 0)
            _ctxt << boost::format("    input wire [%1%:0] %2%, //Type: %3%\n")
                    % (width - 1)
                    % inputName
                    % typestr(ip->type());
        else
            _ctxt << boost::format("    // %1% Type: %2%\n")
                    % inputName 
                    % typestr(ip->type());

        // Technically, the valid shouldn't be necessary, but we may use it for
        // sanity checking.
        _ctxt << boost::format("    input wire %1%_valid,\n") % inputName;
        _ctxt << boost::format("    output wire %1%_bp,\n") % inputName;
        _ctxt << "\n";
    }

    _ctxt << "// Virtual (internal) outputs\n\n";
    for (auto&& op: _sr->internalOutputs()) {
        auto outputName = _ctxt.name(op, true);
        auto width = bitwidth(op->type());
        if (bitwidth(op->type()) > 0)
            _ctxt << boost::format("    output wire [%1%:0] %2%, //Type: %3%\n")
                    % (width - 1)
                    % outputName
                    % typestr(op->type());
        else
            _ctxt << boost::format("    // %1% Type: %2%\n")
                    % outputName
                    % typestr(op->type());

        _ctxt << boost::format("    output wire %1%_valid,\n") % outputName;
        // Technically, the BP shouldn't be necessary, but we may use it for
        // sanity checking.
        _ctxt << boost::format("    input wire %1%_bp,\n") % outputName;
        _ctxt << "\n";
    }

    // End I/O block
    _ctxt << "\n"
          << "    input wire clk,\n"
          << "    input wire resetn\n";
    _ctxt << ");\n\n";
}

void ScheduledRegionVerilogPrinter::writeStartControl() {
    _ctxt << "\n// ***** Start control *****\n";
    _ctxt << "    wire " << _ctxt.name(_sr->startControl()) << "_valid = \n";
    for (auto&& ip: _sr->externalInputs()) {
        _ctxt << "        " << _ctxt.name(ip, true) << "_valid &\n";
    }
    _ctxt << "        1'b1;\n";
    _ctxt << "    wire " << _ctxt.name(_sr->startControl()) << "_bp;\n";
    for (auto&& ip: _sr->externalInputs()) {
        _ctxt << boost::format(
            "    assign %1%_bp = %2%_bp;\n")
            % _ctxt.name(ip, true)
            % _ctxt.name(_sr->startControl());
    }
}

void ScheduledRegionVerilogPrinter::writeConstants() {
    _ctxt << "// ***** Constants *****\n";
    set<Block*> allBlocks;
    _sr->connsConst()->findAllBlocks(allBlocks);
    for (auto b: allBlocks) {
        if (b->inputs().size() == 0) {
            write(nullptr, b);
        }
    }
}

void ScheduledRegionVerilogPrinter::write(const ScheduledRegion::Cycle* cycle,
                                          const OutputPort* op) {
    write(cycle, op->owner());
}

void ScheduledRegionVerilogPrinter::write(const ScheduledRegion::Cycle* cycle,
                                          const InputPort* ip) {
    if (ip->owner()->module() == _sr) {
        write(cycle, ip->owner());
    } else {
        // This IP is virtual. Make sure its sink gets driven
        auto source = _sr->module()->connsConst()->findSource(ip);
        if (source != nullptr && source->owner() == _sr) {
            auto sink = _sr->getSink(source);
            assert(sink != nullptr);
            write(cycle, sink);
        }
    }
}

void ScheduledRegionVerilogPrinter::write(const ScheduledRegion::Cycle* cycle,
                                          Block* b) {
    assert(b->module() == _sr);
    if (_written.count(b) > 0) {
        return;
    }

    //***
    // Write out deps first so verilog can resolve wire names
    auto conns = _sr->connsConst();
    for (InputPort* ip: b->inputs()) {
        auto source = conns->findSource(ip);
        if (source == nullptr) {
            if (b->isnot<DummyBlock>()) {
                // If this is an I/O, unconnected inputs are expected.
                // Otherwise...
                printf("Warning: found unconnected input %s\n",
                       _ctxt.name(ip).c_str());
            }
        } else {
            write(cycle, source);
        }
    }

    //***
    // Special cases
    //
    if (b->is<PipelineRegister>())
        return write(cycle, b->as<PipelineRegister>());
    if (b->is<PipelineStageController>())
        return write(cycle, b->as<PipelineStageController>());
    if (b->is<DummyBlock>())
        return write(cycle, b->as<DummyBlock>());

    //***
    // Normal case
    //
    auto printer = _parent->getPrinter(b);
    auto blockName = _ctxt.name(b);
    auto blockType = cpp_demangle(typeid(*b).name());
    if (printer == nullptr) {
        throw ImplementationError(
            str(boost::format(
                    " Cannot translate block %1% of type %2% into verilog.") 
                        % blockName
                        % blockType));
    }
    _ctxt << boost::format("\n    // Block %1% of type %2%\n")
                % blockName
                % blockType;
    for (InputPort* ip: b->inputs()) {
        if (bitwidth(ip->type()) > 0) {
            auto source = conns->findSource(ip);
            _ctxt << boost::format("    wire [%1%-1:0] %2% = %3%;\n")
                        % bitwidth(ip->type())
                        % _ctxt.name(ip)
                        % _ctxt.name(source) ;
        }
        if (printer->customLID()) {
            _ctxt << boost::format("    wire %1%_valid;\n")
                        % _ctxt.name(ip);
            _ctxt << boost::format("    wire %1%_bp;\n")
                        % _ctxt.name(ip);
        }
    }
    for (OutputPort* op: b->outputs()) {
        if (bitwidth(op->type()) > 0) {
            _ctxt << boost::format("    wire [%1%-1:0] %2%;\n")
                        % bitwidth(op->type())
                        % _ctxt.name(op);
        }
        if (printer->customLID()) {
            _ctxt << boost::format("    wire %1%_valid;\n")
                        % _ctxt.name(op);
            _ctxt << boost::format("    wire %1%_bp;\n")
                        % _ctxt.name(op);
        }
    }

    printer->print(_ctxt, b);

    _written.insert(b);
}

void ScheduledRegionVerilogPrinter::write(const ScheduledRegion::Cycle* cycle,
                                          DummyBlock* b) {
    assert(b->module() == _sr);
    if (_written.count(b) > 0) {
        return;
    }
    _written.insert(b);

    // Write the connection to this I/O
    auto ip = b->din();
    auto ext = _sr->findExternalPortFromSink(ip);
    if (ext != nullptr) {
        _ctxt << "\n    // Output connection\n";
        auto source = _sr->connsConst()->findSource(ip);
        if (source == nullptr) {
            printf("Warning: found undriven SR output: %s.%s\n",
                   _sr->name().c_str(),
                   _ctxt.name(ext, true).c_str());
        } else {
            if (bitwidth(ip->type()) > 0) {
                _ctxt << boost::format(
                    "    assign %1% = %2%;\n")
                    % _ctxt.name((InputPort*)ip)
                    % _ctxt.name(source);
            }

            if (_sr->internalOutputs().count(ext) > 0) {
                // Drive the valid signal here only if it's an internalOutput
                assert(cycle != nullptr);
                _ctxt << boost::format(
                    "    assign %1%_valid = %2%_valid && ~%2%_bp;\n")
                    % _ctxt.name((InputPort*)ip)
                    % validSignal(cycle);
            }
        }
    }
}

void ScheduledRegionVerilogPrinter::write(const ScheduledRegion::Cycle* cycle,
                                          PipelineRegister* reg) {
    assert(reg->module() == _sr);
    if (_written.count(reg) > 0) {
        return;
    }
    _written.insert(reg);

    auto ce = reg->enable();
    assert(ce != nullptr);
    auto ceSource = _sr->connsConst()->findSource(ce);
    assert(ceSource != nullptr);
    auto psc = ceSource->owner()->as<PipelineStageController>();
    assert(psc != nullptr);

    auto din = _sr->connsConst()->findSource(reg->din());
    if (din == nullptr) {
        printf("WARNING: Register not driven! (%s)\n", _ctxt.name(din).c_str());
        return;
    }

    if (bitwidth(reg->dout()->type()) == 0) {
        return;
    }

    _ctxt << boost::format(
        "\n"
        "    wire [%5%-1:0] %4%;\n"
        "    PipelineReg_Slave # (\n"
        "        .Width(%5%),\n"
        "        .Name(\"%1%\")\n"
        "    ) %1% (\n"
        "        .clk(clk),\n"
        "        .resetn(resetn),\n"
        "        .ce_valid(%2%_ce),\n"
        "        .d(%3%),\n"
        "        .q(%4%)\n"
        "    );\n")
        % _ctxt.name(reg)
        % _ctxt.name(psc)
        % _ctxt.name(din)
        % _ctxt.name(reg->dout())
        % bitwidth(reg->dout()->type()) ;
}

std::string ScheduledRegionVerilogPrinter::validSignal(
        const ScheduledRegion::Cycle* cycle) {
    assert(cycle != nullptr);
    auto psc = cycle->controller();
    OutputPort* vinSource = nullptr;
    if (psc == nullptr) {
        // Special case: last cycle has no PSC
        if (_sr->cycles_size() > 1) {
            vinSource = _sr->cycles(_sr->cycles_size() - 2)->controller()->vout(); 
        } else {
            vinSource = _sr->startControl()->dout();
        }
    } else {
        vinSource = _sr->connsConst()->findSource(psc->vin());
    }
    assert(vinSource != nullptr);
    string vin;
    if (vinSource == _sr->startControl()->dout())
        return _ctxt.name(_sr->startControl());
    else
        return _ctxt.name(vinSource);   
}

void ScheduledRegionVerilogPrinter::write(const ScheduledRegion::Cycle* cycle,
                                          PipelineStageController* psc) {
    assert(psc->module() == _sr);
    if (_written.count(psc) > 0) {
        return;
    }
    _written.insert(psc);

    auto vin = validSignal(cycle);
    _ctxt << boost::format(
        "    wire %3%_valid;\n"
        "    wire %3%_bp;\n"
        "    wire %1%_ce;\n"
        "    PipelineStageController %1% (\n"
        "        .clk(clk),\n"
        "        .resetn(resetn),\n"
        "        .vin_valid(%2%_valid),\n"
        "        .vin_bp(%2%_bp),\n"
        "        .vout_valid(%3%_valid),\n"
        "        .vout_bp(%3%_bp),\n"
        "        .ce_valid(%1%_ce)\n"
        "    );\n")
        % _ctxt.name(psc)
        % vin
        % _ctxt.name(psc->vout());
}

void ScheduledRegionVerilogPrinter::writeCycle(unsigned cycleNum) {
    const ScheduledRegion::Cycle* c = _sr->cycles(cycleNum);
    _ctxt << boost::format(
                "\n// ***** Cycle %1%: Computation *****\n")
                % cycleNum;
    auto firing = c->firing();
    for (auto ip: firing) {
        write(c, ip);
    }
    _ctxt << boost::format(
                "\n// ***** Cycle %1%: Registers *****\n")
                % cycleNum;

    if (c->controller() != nullptr)
        write(c, c->controller());
    auto regs = c->regs();
    for (auto rpair: regs) {
        write(c, rpair.second);
    }
}

void ScheduledRegionVerilogPrinter::writeOutputs() {
    _ctxt << "\n// ***** Final output LI bits *****\n";
    const ScheduledRegion::Cycle* lastCycle = _sr->cycles(_sr->cycles_size() - 1);

    _ctxt << boost::format(
        "    wire [%2%-1:0] __outputfork_dout_valid;\n"
        "    wire [%2%-1:0] __outputfork_dout_bp;\n"
        "    Fork_VoidData # (\n"
        "        .NumOutputs(%2%)\n"
        "    ) __outputfork (\n"
        "        .clk(clk),\n"
        "        .resetn(resetn),\n"
        "        .din_valid(%1%_valid),\n"
        "        .din_bp(%1%_bp),\n"
        "        .dout_valid(__outputfork_dout_valid),\n"
        "        .dout_bp(__outputfork_dout_bp)\n"
        "    );\n")
        % validSignal(lastCycle)
        % _sr->externalOutputs().size();
    unsigned idx = 0;
    for (auto op: _sr->externalOutputs()) {
        assert(_written.count(_sr->getSink(op)->owner()) > 0);
        _ctxt << boost::format(
            "    assign %1%_valid = __outputfork_dout_valid[%2%];\n"
            "    assign __outputfork_dout_bp[%2%] = %1%_bp;\n")
            % _ctxt.name(op, true)
            % idx;
        idx++;
    }
}

} // namespace llpm
