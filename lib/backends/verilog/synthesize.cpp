#include "synthesize.hpp"

#include <cmath>

#include <synthesis/pipeline.hpp>
#include <libraries/synthesis/pipeline.hpp>
#include <util/llvm_type.hpp>
#include <util/misc.hpp>
#include <refinery/refinery.hpp>

#include <libraries/core/comm_intr.hpp>
#include <libraries/core/std_library.hpp>
#include <libraries/synthesis/memory.hpp>
#include <libraries/synthesis/fork.hpp>

#include <llvm/IR/Constants.h>

#include <boost/format.hpp>

using namespace std;

namespace llpm {

VerilogSynthesizer::VerilogSynthesizer(Design& d) :
    _design(d)
{
    StdLibStops(_stops);
    addStops();
    addDefaultPrinters();
}

void VerilogSynthesizer::addStops() {
    _stops.addClass<BlockRAM>();
}

void VerilogSynthesizer::write(std::ostream& os) {
    auto& modules = _design.modules();
    for (auto& m: modules) {
        writeModule(os, m);
    }
}

InputPort* VerilogSynthesizer::findSink(const ConnectionDB* conns,
                                        const OutputPort* op) {
    vector<InputPort*> ports;
    conns->findSinks(op, ports);
    if (ports.size() == 0)
        return NULL;
    if (ports.size() == 1)
        return ports.front();
    throw InvalidCall("Synthesis does not support fan out greater than 1! "
                      "Run a pass to create forking blocks first");
}

static const std::string header = R"STRING(
/*****************
 *  This code autogenerated by LLPM.
 *  DO NOT MODIFY MANUALLY!
 *  Manual changes will be overwritten.
 ******/
)STRING";

void VerilogSynthesizer::writeModule(FileSet::File* f, Module* mod) {
    writeModule(f->openStream(), mod);
    f->close();
}


void VerilogSynthesizer::writeModule(std::ostream& os, Module* mod) {
    // Write out header
    os << header;
    writeModuleOnly(os, mod);
}

void VerilogSynthesizer::writeModuleOnly(std::ostream& os, Module* mod) {
    Context ctxt(os, mod);

    Pipeline* p = mod->pipeline();
    p->build();

    ctxt << "\n\n";
    ctxt << "// The \"" << mod->name() << "\" module of type "
         << cpp_demangle(typeid(*mod).name()) << "\n";
    ctxt << "module " << mod->name() << " (\n";


    ctxt.namer().reserveName("clk", mod);
    ctxt.namer().reserveName("resetn", mod);

    writeIO(ctxt);
    writeBlocks(ctxt);

    ctxt << "endmodule\n";


    vector<Module*> submodules;
    mod->submodules(submodules);
    for (Module* sm: submodules) {
        ControlRegion* cr = dynamic_cast<ControlRegion*>(sm);
        if (cr != NULL) {
            ctxt << "\n";
            writeModuleOnly(os, cr);
        }
    }
}

void VerilogSynthesizer::writeIO(Context& ctxt) {
    Module* mod = ctxt.module();

    for (auto&& ip: mod->inputs()) {
        auto inputName = ctxt.name(ip, true);
        auto width = bitwidth(ip->type());
        if (bitwidth(ip->type()) > 0)
            ctxt << boost::format("    input [%1%:0] %2%, //Type: %3%\n")
                    % (width - 1)
                    % inputName
                    % typestr(ip->type());
        ctxt << boost::format("    input %1%_valid,\n") % inputName;
        ctxt << boost::format("    output %1%_bp,\n") % inputName;

    }
    ctxt << "\n";
    for (auto&& op: mod->outputs()) {
        auto outputName = ctxt.name(op, true);
        auto width = bitwidth(op->type());
        if (bitwidth(op->type()) > 0)
            ctxt << boost::format("    output [%1%:0] %2%, //Type: %3%\n")
                    % (width - 1)
                    % outputName
                    % typestr(op->type());
        ctxt << boost::format("    output %1%_valid,\n") % outputName;
        ctxt << boost::format("    input %1%_bp,\n") % outputName;
    }

    ctxt << "\n"
         << "    input clk,\n"
         << "    input resetn\n"
         << ");\n\n";
    

    ConnectionDB* conns = mod->conns();
    if (conns == NULL) {
        throw InvalidArgument("Verilog synthesizer cannot operate on opaque modules!");
    }

    ctxt << "    // Input back pressure connection\n";
    for (auto&& ip: mod->inputs()) {
        OutputPort* dummyOP = mod->getDriver(ip);

        ctxt.namer().assignName(dummyOP, mod, ctxt.name(ip, true));

        InputPort* sink = findSink(conns, dummyOP);
        if (sink) {
            ctxt << boost::format("    assign %1%_bp = %2%_bp;\n")
                        % ctxt.name(ip, true)
                        % ctxt.name(sink);
        } else {
            ctxt << boost::format("    assign %1%_bp = 1'b0;\n")
                        % ctxt.name(ip, true);
        }
    }

    for (auto&& op: mod->outputs()) {
        InputPort* dummyIP = mod->getSink(op);
        ctxt.namer().assignName(dummyIP, mod, ctxt.name(op, true));
        OutputPort* source = conns->findSource(dummyIP);
        if (bitwidth(op->type()) > 0)
            ctxt << boost::format("    assign %1% = %2%;\n")
                        % ctxt.name(op, true)
                        % ctxt.name(source);
        ctxt << boost::format("    assign %1%_valid = %2%_valid;\n")
                    % ctxt.name(op, true)
                    % ctxt.name(source);
    }

    ctxt << "\n";
}

void VerilogSynthesizer::writeBlocks(Context& ctxt) {
    ConnectionDB* conns = ctxt.module()->conns();
    
    vector<Block*> blocks;
    ctxt.module()->blocks(blocks);
    for (Block* b: blocks) {
        if (dynamic_cast<DummyBlock*>(b) != NULL)
            continue;

        ctxt << "    // Block \"" << ctxt.primBlockName(b) << "\" type "
             << cpp_demangle(typeid(*b).name()) << "\n";
        for (InputPort* ip: b->inputs()) {
            Connection c;
            auto inpFound = conns->find(ip, c);
            std::string opName;
            if (!inpFound) {
                fprintf(stderr, "Warning: no driver found for input %s!\n",
                        ctxt.name(ip).c_str());
                fprintf(stderr, "         input %u of %lu of block %s type %s\n",
                                b->inputNum(ip)+1, b->inputs().size(),
                                ctxt.name(b).c_str(), cpp_demangle(typeid(*b).name()).c_str());
                opName = "UNKNOWN";
            } else {
                opName = ctxt.name(c.source());
            }

            if (bitwidth(ip->type()) == 0) {
                ctxt << boost::format("    reg %1%_valid = %2%_valid;\n"
                                      "    reg %1%_bp;\n")
                            % ctxt.name(ip)
                            % opName;
            } else {
                ctxt << boost::format("    reg [%1%-1:0] %2% = %3%;\n"
                                      "    reg %2%_valid = %3%_valid;\n"
                                      "    reg %2%_bp;\n")
                            % bitwidth(ip->type())
                            % ctxt.name(ip)
                            % opName;
            }
        }

        for (OutputPort* op: b->outputs()) {
            if (bitwidth(op->type()) == 0) {
                ctxt << boost::format("    reg %1%_valid;\n"
                                      "    reg %1%_bp = ")
                            % ctxt.name(op);
            } else {
                ctxt << boost::format("    reg [%1%-1:0] %2%;\n"
                                      "    reg %2%_valid;\n"
                                      "    reg %2%_bp = ")
                            % bitwidth(op->type())
                            % ctxt.name(op);
            }

            InputPort* sink = findSink(conns, op);
            if (sink) {
                ctxt << ctxt.name(sink) << "_bp;\n";
            } else {
                ctxt << "1'b0;\n";
            }
        }

        print(ctxt, b);
        ctxt << "\n";
    }


}

void VerilogSynthesizer::print(Context& ctxt, Block* b)
{
    const vector<Printer*>& possible_printers = _printers(b);
    if (possible_printers.size() == 0) {
        auto blockName = ctxt.name(b);
        throw ImplementationError(
            str(boost::format(" Cannot translate block %1% of type %2% into verilog.") 
                            % blockName
                            % cpp_demangle(typeid(*b).name())));
    } else {
        auto printer = possible_printers.front();
        printer->print(ctxt, b);

        if (!printer->customLID()) {
            assert(!b->outputsIndependent());

            std::string joinOp;
            std::string terminator;
            switch (b->firing()) {
            case DependenceRule::AND:
                joinOp = "&";
                terminator = "1'b1";
                break;
            case DependenceRule::OR:
                joinOp = "|";
                terminator = "1'b0";
                break;
            case DependenceRule::Custom:
                assert(printer->customLID() &&
                       "This default printer can't deal with custom"
                       "firing rules!");
            }

            ctxt << "    wire " << ctxt.name(b) << "_valid = \n";
            for (auto ip: b->inputs()) {
                ctxt << "        " << ctxt.name(ip) << "_valid " << joinOp << "\n";
            }
            ctxt << "        " << terminator << ";\n";

            for (auto op: b->outputs()) {
                ctxt << "    assign " << ctxt.name(op) << "_valid = " << ctxt.name(b) << "_valid;\n";
            }


            ctxt << "    wire " << ctxt.name(b) << "_bp = \n";
            ctxt << "        ~" << ctxt.name(b) << "_valid | \n";
            for (auto op: b->outputs()) {
                ctxt << "        " << ctxt.name(op) << "_bp | " << "\n";
            }
            ctxt << "        1'b0;\n";

            for (auto ip: b->inputs()) {
                ctxt << "    assign " << ctxt.name(ip) << "_bp = " << ctxt.name(b) << "_bp;\n";
            }
        }
    }
}

void print_function(VerilogSynthesizer::Context& ctxt, Block* c,
                    const char* op, bool signedWrap) {
    Function* b = dynamic_cast<Function*>(c);
    ctxt << "    assign " << ctxt.name(b->dout()) << " = ";
    auto dinType = b->din()->type();
    assert(dinType->isStructTy());
    auto dinName = ctxt.name(b->din());
    bool first = true;
    for (unsigned i = 0; i < numContainedTypes(dinType); i++) {
        unsigned offset = bitoffset(dinType, i);
        unsigned width = bitwidth(nthType(dinType, i));
        if (width == 0)
            continue;
        if (first)
            first = false;
        else
            ctxt << " " << op << " ";
        if (signedWrap)
            ctxt << boost::format("$signed(%1%[%2%:%3%])") 
                            % dinName
                            % (offset+width-1)
                            % offset;
        else 
            ctxt << boost::format("%1%[%2%:%3%]") 
                            % dinName
                            % (offset+width-1)
                            % offset;
    }
    ctxt << ";\n";
}

template<typename BlockType>
class BinaryOpPrinter : public VerilogSynthesizer::Printer {
    const char* _op;
public:
    BinaryOpPrinter(const char* op) : _op(op) { }

    bool handles(Block* b) const {
        return dynamic_cast<BlockType*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        bool signedWrap = false;
        if (IntDivide* id = dynamic_cast<IntDivide*>(c))
            signedWrap = id->isSigned();
        if (IntRemainder* ir = dynamic_cast<IntRemainder*>(c))
            signedWrap = ir->isSigned();
        print_function(ctxt, c, _op, signedWrap);
    }
};

class CompareOpPrinter : public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<IntCompare*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        const char* op = NULL;
        IntCompare* b = dynamic_cast<IntCompare*>(c);

        switch (b->op()) {
        case IntCompare::EQ:
            op = "==";
            break;
        case IntCompare::NEQ:
            op = "!=";
            break;
        case IntCompare::GT:
            op = ">";
            break;
        case IntCompare::GTE:
            op = ">=";
            break;
        }
        print_function(ctxt, c, op, b->isSigned());
    }
};

class BitwiseOpPrinter : public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Bitwise*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        const char* op = NULL;
        Bitwise* b = dynamic_cast<Bitwise*>(c);
        switch (b->op()) {
        case Bitwise::AND:
            op = "&";
            break;
        case Bitwise::OR:
            op = "|";
            break;
        case Bitwise::XOR:
            op = "^";
            break;
        }
        print_function(ctxt, c, op, false);
    }
};

class ShiftPrinter : public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Shift*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        const char* op = NULL;
        Shift* s = dynamic_cast<Shift*>(c);
        
        switch (s->dir()) {
        case Shift::Left:
            op = "<<";
            break;
        case Shift::Right:
            op = ">>";
            break;
        }

        switch (s->style()) {
        case Shift::Logical:
            print_function(ctxt, c, op, false);
            break;
        case Shift::Rotating: {
            assert(false && "Rotating shifts not yet implemented!");
            break;
        }
        case Shift::Arithmetic:
            assert(s->style() == Shift::Arithmetic);
            print_function(ctxt, c, ">>>", false);
            break;
        }
    }
};

class IntTruncatePrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<IntTruncate*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Function* f = dynamic_cast<Function*>(c);
        ctxt << "    assign " << ctxt.name(f->dout()) << " = "
             << boost::format("%1%[%2%:0];\n")
                            % ctxt.name(f->din())
                            % (bitwidth(f->dout()->type()) - 1);
    }
};

class IntExtendPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<IntExtend*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        IntExtend* f = dynamic_cast<IntExtend*>(c);
        unsigned ib = bitwidth(f->din()->type());
        unsigned ob = bitwidth(f->dout()->type());
        assert(ob > ib);
        string msb = str(boost::format("%1%[%2%]")
                            % ctxt.name(f->din())
                            % (ib - 1));
        ctxt << "    assign " << ctxt.name(f->dout()) << " = { "
             << boost::format("{%1%{%2%}}")
                % (ob - ib)
                % ( f->signExtend() ? msb : "1'b0")
             << ", " << ctxt.name(f->din()) << "};\n";
    }
};

template<typename Op>
class IdentityOpPrinter : public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Op*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Op* f = dynamic_cast<Op*>(c);
        if (bitwidth(f->din()->type()) > 0)
            ctxt << "    assign " << ctxt.name(f->dout()) << " = "
                 << ctxt.name(f->din()) << ";\n";
    }
};

class ConstantPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Constant*>(b) != NULL;
    }

    static std::string toString(llvm::Type* ty, llvm::Constant* lc) {
        if (ty == NULL)
            ty = lc->getType();

        if (lc != NULL &&
            lc->getValueID() == llvm::Value::UndefValueVal) {
            return str(boost::format("{%1%{1'bx}}") %
                            bitwidth(ty));
        };

        unsigned valueID;
        if (lc != NULL) {
            valueID = lc->getValueID();
        } else {
            switch(ty->getTypeID()) {
            case llvm::Type::IntegerTyID:
                valueID = llvm::Value::ConstantIntVal;
                break;
            case llvm::Type::PointerTyID:
                valueID = llvm::Value::ConstantPointerNullVal;
                break;
            case llvm::Type::VectorTyID:
                valueID = llvm::Value::ConstantAggregateZeroVal;
                break;
            default:
                valueID = -1;
            }
        }

        switch (valueID) {
            case llvm::Value::ConstantIntVal:
                return str(boost::format("%1%'d%2%") 
                            % bitwidth(ty)
                            % llvm::dyn_cast<llvm::ConstantInt>(lc)->
                                    getValue().toString(10, true));
            case llvm::Value::ConstantPointerNullVal:
                assert(lc == NULL || lc->isNullValue());
                return str(boost::format("%1%'h%2%") 
                            % bitwidth(ty)
                            % 0);
            case llvm::Value::ConstantAggregateZeroVal: 
                return str(boost::format("{%1%{1'b0}}")
                            % bitwidth(ty));
            case llvm::Value::ConstantDataVectorVal: {
                llvm::ConstantDataVector* cv =
                    llvm::dyn_cast<llvm::ConstantDataVector>(lc);
                assert(cv != NULL);
                std::string ret = "{";
                unsigned len = numContainedTypes(ty);
                for (unsigned i=len; i>0; i--) {
                    ret += toString(NULL, cv->getElementAsConstant(i-1)) + 
                            (i == 1 ? "" : ", ");
                }
                ret += "}";
                return ret;
            }
        default:
            throw InvalidArgument("Constant type not yet supported");
        }
    }

    static std::string toString(Constant* c) {
        llvm::Constant* lc = c->value();
        return toString(c->dout()->type(), lc);
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Constant* f = dynamic_cast<Constant*>(c);
        if (bitwidth(f->dout()->type()) > 0)
            ctxt << "    assign " << ctxt.name(f->dout()) << " = "
                 << toString(f) << ";\n";
    }
};

class JoinPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Join*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Join* j = dynamic_cast<Join*>(c);
        if (bitwidth(j->dout()->type()) == 0)
            return;
        ctxt << "    assign " << ctxt.name(j->dout()) << " = { ";
        bool first = true;
        for (signed i = j->din_size() - 1; i >= 0; i--) {
            if (bitwidth(j->din(i)->type()) == 0)
                continue;
            if (first)
                first = false;
            else
                ctxt << ", ";
            ctxt << ctxt.name(j->din(i));
        }
        ctxt << " };\n";
    }
};

class SplitPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Split*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Split* s = dynamic_cast<Split*>(c);
        auto dinName = ctxt.name(s->din());
        for (unsigned i=0; i < s->dout_size(); i++) {
            if (bitwidth(s->dout(i)->type()) == 0)
                continue;
            unsigned offset = bitoffset(s->din()->type(), i);
            unsigned width = bitwidth(nthType(s->din()->type(), i));
            ctxt << "    assign " << ctxt.name(s->dout(i)) << " = "
                 << boost::format("%1%[%2%:%3%];\n") 
                        % dinName
                        % (offset+width-1)
                        % offset;
        }
    }
};

class ExtractPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Extract*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Extract* e = dynamic_cast<Extract*>(c);
        auto dinName = ctxt.name(e->din());
        unsigned offset = 0; 
        llvm::Type* type = e->din()->type();
        for (unsigned i: e->path()) {
            offset += bitoffset(type, i);
            type = nthType(type, i);
        }

        unsigned width = bitwidth(e->dout()->type());

        ctxt << "    assign " << ctxt.name(e->dout()) << " = "
             << boost::format("%1%[%2%:%3%];\n") 
                    % dinName
                    % (offset+width-1)
                    % offset;
    }
};

class MultiplexerPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Multiplexer*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Multiplexer* m = dynamic_cast<Multiplexer*>(c);
        auto doutName = ctxt.name(m->dout());
        auto dinType = m->din()->type();
        auto dinName = ctxt.name(m->din());
        unsigned nWidth = bitwidth(nthType(dinType, 0));
        unsigned nOffset = bitoffset(dinType, 0);

        ctxt << "    always\n"
             << "    begin\n"
             << boost::format("        case (%1%[%2%:%3%])\n") 
                    % dinName
                    % (nWidth + nOffset - 1)
                    % nOffset;
        for (size_t i=1; i<numContainedTypes(dinType); i++) {
            auto offset = bitoffset(dinType, i);
            ctxt << boost::format("            %1% : %2% = %3%[%4%:%5%];\n")
                        % (i - 1)
                        % doutName
                        % dinName
                        % (offset + bitwidth(nthType(dinType, i)) - 1)
                        % offset;
        }
        ctxt << "        endcase\n"
             << "    end\n";
    }
};

class RouterPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Router*>(b) != NULL;
    }

    virtual bool customLID() const {
        return true;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Router* r = dynamic_cast<Router*>(c);
        auto dinName = ctxt.name(r->din());
        auto dinType = nthType(r->din()->type(), 1);
        auto dinOffset = bitoffset(r->din()->type(), 1);
        auto dinWidth = bitwidth(dinType);

        auto selType = nthType(r->din()->type(), 0);
        auto selWidth = bitwidth(selType);
        auto selOffset = bitoffset(r->din()->type(), 0);

        for (unsigned i=0; i<r->dout_size(); i++) {
            auto op = r->dout(i);
            if (dinWidth > 0) {
                ctxt << boost::format(
                    "    assign %8% = (%1%[%2%:%3%] == %4%) ? \n"
                    "        %1%[%5%:%6%] : {%7%{1'bx}};\n")
                    % dinName
                    % (selWidth + selOffset - 1)
                    % selOffset
                    % i
                    % (dinWidth + dinOffset - 1)
                    % dinOffset
                    % dinWidth
                    % ctxt.name(op);
            }
            ctxt << boost::format(
                "    assign %5%_valid = (%1%[%2%:%3%] == %4%) ? \n"
                "        %1%_valid : 1'b0;\n")
                % dinName
                % (selWidth + selOffset - 1)
                % selOffset
                % i
                % ctxt.name(op);
        }
        ctxt << "    assign " << dinName << "_bp = \n";
        for (unsigned i=0; i<r->dout_size(); i++) {
            auto op = r->dout(i);
            ctxt << boost::format("        (%1%_bp & %1%_valid) |\n")
                        % ctxt.name(op);
        }
        ctxt << "        1'b0;\n";
    }
};

class SelectPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Select*>(b) != NULL;
    }

    virtual bool customLID() const {
        return true;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Select* s = dynamic_cast<Select*>(c);
        std::string style = "LLPM_Select_Priority";
    
        ctxt << boost::format("    wire [%1%:0] %2%_input_combined [%3%:0];\n") 
                            % (bitwidth(s->dout()->type()) - 1)
                            % ctxt.name(s)
                            % (s->din_size() - 1)
             << boost::format("    wire %1%_valids[%2%:0];\n") 
                            % ctxt.name(s)
                            % (s->din_size() - 1)
             << boost::format("    wire %1%_bp[%2%:0];\n") 
                            % ctxt.name(s)
                            % (s->din_size() - 1)
            ;
        for (unsigned i=0; i<s->din_size(); i++) {
            ctxt << boost::format("    assign %1%_input_combined[%2%] = %3%;\n")
                            % ctxt.name(s)
                            % i
                            % ctxt.name(s->din(i))
                 << boost::format("    assign %1%_valids[%2%] = %3%_valid;\n")
                            % ctxt.name(s)
                            % i
                            % ctxt.name(s->din(i))
#if 0
                 << boost::format("    assign %3%_bp = %1%_bp[%2%];\n")
                            % ctxt.name(s)
                            % i
                            % ctxt.name(s->din(i))
#endif
                ;
        }

        ctxt << boost::format("    %1% # (\n") % style
             << boost::format("        .Width(%1%),\n") % bitwidth(s->dout()->type())
             << boost::format("        .NumInputs(%1%), \n") % s->din_size()
             << boost::format("        .CLog2NumInputs(%1%)\n") 
                        % std::max((unsigned)1, (unsigned)ceil(log2(s->din_size())))
             << boost::format("    ) %1% (\n") % ctxt.name(c)
             <<               "        .clk(clk),\n"
             <<               "        .resetn(resetn),\n"

             << boost::format("        .x(%1%_input_combined), \n") % ctxt.name(s)
             << boost::format("        .x_valid(%1%_valids), \n") % ctxt.name(s)
             << boost::format("        .x_bp(%1%_bp), \n") % ctxt.name(s)

             << boost::format("        .a(%1%), \n") % ctxt.name(s->dout())
             << boost::format("        .a_valid(%1%_valid), \n") % ctxt.name(s->dout())
             << boost::format("        .a_bp(%1%_bp) \n") % ctxt.name(s->dout())
             <<               "    );\n"
             ;

        for (unsigned i=0; i<s->din_size(); i++) {

                 ctxt << boost::format("    assign %3%_bp = %1%_bp[%2%];\n")
                            % ctxt.name(s)
                            % i
                            % ctxt.name(s->din(i))
                ;
        }
    }
};

class ForkPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Fork*>(b) != NULL;
    }

    virtual bool customLID() const {
        return true;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* b) const {
        Fork* f = dynamic_cast<Fork*>(b);
        std::string style;
        if (f->virt())
            style = "VirtFork";
        else 
            style = "Fork";
    
        ctxt << boost::format(
                "    wire [%3%:0] %1%_dout;\n"
                "    wire [%2%:0] %1%_dout_valids;\n"
                "    wire [%2%:0] %1%_dout_bp;\n") 
                    % ctxt.name(f)
                    % (f->dout_size() - 1)
                    % (bitwidth(f->din()->type()) - 1);
        for (unsigned i=0; i<f->dout_size(); i++) {
            ctxt << boost::format(
                "    assign %3% = %1%_dout;\n"
                "    assign %3%_valid = %1%_dout_valids[%2%];\n"
                "    assign %1%_dout_bp[%2%] = %3%_bp;\n")
                    % ctxt.name(f)
                    % i
                    % ctxt.name(f->dout(i));
        }

        ctxt << boost::format("    %1% # (\n") % style
             << boost::format("        .Width(%1%),\n") 
                             % bitwidth(f->din()->type())
             << boost::format("        .NumOutputs(%1%)\n")
                             % f->dout_size()
             << boost::format("    ) %1% (\n") % ctxt.name(f)
             <<               "        .clk(clk),\n"
             <<               "        .resetn(resetn),\n"

             << boost::format("        .din(%2%), \n"
                              "        .din_valid(%2%_valid), \n"
                              "        .din_bp(%2%_bp), \n"
                              "        .dout(%1%_dout), \n"
                              "        .dout_valid(%1%_dout_valids), \n"
                              "        .dout_bp(%1%_dout_bp) \n")
                             % ctxt.name(f)
                             % ctxt.name(f->din())
             <<               "    );\n";
    }
};

struct AttributePrinter {
    template<typename T>
    void print(VerilogSynthesizer::Context& ctxt,
               string k, T t, bool last = false) {
        ctxt << boost::format("        .%1%(%2%)%3%\n")
                    % k
                    % t
                    % (last ? "" : ",");
    }

};



template<typename BType, typename Attrs>
class VModulePrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<BType*>(b) != NULL;
    }

    virtual bool customLID() const {
        return true;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* b) const {
        BType* mod = dynamic_cast<BType*>(b);
        assert(mod != NULL);

        Attrs a;
        ctxt << "    " << a.name(mod) << " # ( \n";
        a(ctxt, mod);
        ctxt << "    ) " << ctxt.name(mod) << " (\n";

        for (InputPort* ip: mod->inputs()) {
            if (bitwidth(ip->type()) > 0)
                ctxt << boost::format("        .%1%(%2%),\n")
                        % ctxt.name(ip, true)
                        % ctxt.name(ip);
            ctxt << boost::format("        .%1%_valid(%2%_valid),\n"
                                  "        .%1%_bp(%2%_bp),\n")
                    % ctxt.name(ip, true)
                    % ctxt.name(ip);
        }

        for (OutputPort* op: mod->outputs()) {
            if (bitwidth(op->type()) > 0)
                ctxt << boost::format("        .%1%(%2%),\n")
                        % ctxt.name(op, true)
                        % ctxt.name(op);
            ctxt << boost::format("        .%1%_valid(%2%_valid),\n"
                                  "        .%1%_bp(%2%_bp),\n")
                    % ctxt.name(op, true)
                    % ctxt.name(op);
        }

        ctxt << "        .clk(clk),\n"
             << "        .resetn(resetn)\n";

        ctxt << "    );\n";
    }
};

struct ModulePrinter : public AttributePrinter {
    std::string name(Module* m) {
        return m->name();
    }
    void operator()(VerilogSynthesizer::Context& ctxt, Block* b) { }
};

struct PipelineRegPrinter : public AttributePrinter {
    std::string name(Block* m) {
        return "PipelineReg_DoubleWidth";
    }
    void operator()(VerilogSynthesizer::Context& ctxt, PipelineRegister* r) {
        print(ctxt, "Width", bitwidth(r->din()->type()), true);
    }
};

struct RTLRegAttr : public AttributePrinter {
    std::string name(Block* b) {
        return "RTLReg";
    }
    void operator()(VerilogSynthesizer::Context& ctxt, RTLReg* r) {
        print(ctxt, "Width", bitwidth(r->type()), true);
    }
};

struct BlockRAMAttr: public AttributePrinter {
    std::string name(Block* b) {
        BlockRAM* bram = dynamic_cast<BlockRAM*>(b);
        return str(boost::format("BlockRAM_%1%RW") % bram->ports_size());
    }
    void operator()(VerilogSynthesizer::Context& ctxt, BlockRAM* b) {
        print(ctxt, "Width", bitwidth(b->type()), false);
        print(ctxt, "Depth", b->depth(), false);
        print(ctxt, "AddrWidth", idxwidth(b->depth()), true);
    }
};

void VerilogSynthesizer::addDefaultPrinters() {
    _printers.appendEntry(new BinaryOpPrinter<IntAddition>("+"));
    _printers.appendEntry(new BinaryOpPrinter<IntSubtraction>("-"));
    _printers.appendEntry(new BinaryOpPrinter<IntMultiply>("*"));
    _printers.appendEntry(new BinaryOpPrinter<IntDivide>("/"));
    _printers.appendEntry(new BinaryOpPrinter<IntRemainder>("%"));

    _printers.appendEntry(new CompareOpPrinter());
    _printers.appendEntry(new BitwiseOpPrinter());
    _printers.appendEntry(new ShiftPrinter());

    _printers.appendEntry(new IntTruncatePrinter());
    _printers.appendEntry(new IntExtendPrinter());

    _printers.appendEntry(new IdentityOpPrinter<Identity>());
    _printers.appendEntry(new IdentityOpPrinter<Cast>());
    _printers.appendEntry(new IdentityOpPrinter<Wait>());

    _printers.appendEntry(new ConstantPrinter());

    _printers.appendEntry(new JoinPrinter());
    _printers.appendEntry(new SelectPrinter());
    _printers.appendEntry(new SplitPrinter());
    _printers.appendEntry(new ExtractPrinter());
    _printers.appendEntry(new ForkPrinter());

    _printers.appendEntry(new MultiplexerPrinter());
    _printers.appendEntry(new RouterPrinter());

    _printers.appendEntry(new VModulePrinter<PipelineRegister,
                                             PipelineRegPrinter>());
    _printers.appendEntry(new VModulePrinter<RTLReg, RTLRegAttr>());
    _printers.appendEntry(new VModulePrinter<BlockRAM, BlockRAMAttr>());
    _printers.appendEntry(new VModulePrinter<Module, ModulePrinter>());
}

bool VerilogSynthesizer::blockIsPrimitive(Block* b) {
    return primitiveStops()->stopRefine(b);
}

} // namespace llpm
