#include "synthesize.hpp"

#include <cmath>

#include <synthesis/pipeline.hpp>
#include <libraries/synthesis/pipeline.hpp>
#include <util/llvm_type.hpp>
#include <util/misc.hpp>
#include <refinery/refinery.hpp>

#include <libraries/core/comm_intr.hpp>
#include <libraries/core/std_library.hpp>
#include <libraries/synthesis/memory.hpp>

#include <llvm/IR/Constants.h>

#include <boost/format.hpp>

using namespace std;

namespace llpm {

VerilogSynthesizer::VerilogSynthesizer(Design& d) :
    _design(d)
{
    StdLibStops(_stops);
    addDefaultPrinters();
}

void VerilogSynthesizer::write(std::ostream& os) {
    auto& modules = _design.modules();
    for (auto& m: modules) {
        writeModule(os, m);
    }
}

static const std::string header = R"STRING(
/*****************
 *  This code autogenerated by LLPM.
 *  DO NOT MODIFY MANUALLY!
 *  Manual changes will be overwritten.
 ******/

// Macros used in autogenerated verilog
`define DFF(W, N, D, CE)\
        always@(posedge clk)\
        begin\
            if (~resetn)\
                N <= {W{1'b0}};\
            else if (CE)\
                N <= D;\
        end
`define LI_CONTROL(V_OUT, V_IN, BP_OUT, BP_IN, CE)\
        reg V_OUT``_internal;\
        assign V_OUT = V_OUT``_internal;\
        assign BP_OUT = V_OUT``_internal;\
        wire CE = V_IN && ~BP_OUT;\
        always@(posedge clk)\
        begin\
            if (~resetn)\
                V_OUT``_internal <= 1'b0;\
            else begin\
                if (V_OUT && ~BP_IN)\
                    V_OUT``_internal <= 1'b0;\
                if (CE)\
                    V_OUT``_internal <= 1'b1;\
            end\
        end
)STRING";

void VerilogSynthesizer::writeModule(FileSet::File* f, Module* mod) {
    writeModule(f->openStream(), mod);
    f->close();
}


void VerilogSynthesizer::writeModule(std::ostream& os, Module* mod) {
    // Write out header
    os << header;
    writeModuleOnly(os, mod);
}

void VerilogSynthesizer::writeModuleOnly(std::ostream& os, Module* mod) {
    Context ctxt(os, mod);

    printf("Pipelining...\n");
    Pipeline* p = mod->pipeline();
    p->build();

    ctxt << "\n\n";
    ctxt << "// The \"" << mod->name() << "\" module of type "
         << cpp_demangle(typeid(*mod).name()) << "\n";
    ctxt << "module " << mod->name() << " (\n";


    ctxt.namer().reserveName("clk", mod);
    ctxt.namer().reserveName("resetn", mod);

    writeIO(ctxt);
    writeBlocks(ctxt);

    ctxt << "endmodule\n";


    vector<Module*> submodules;
    mod->submodules(submodules);
    for (Module* sm: submodules) {
        ControlRegion* cr = dynamic_cast<ControlRegion*>(sm);
        if (cr != NULL) {
            ctxt << "\n";
            writeModuleOnly(os, cr);
        }
    }
}

void VerilogSynthesizer::writeIO(Context& ctxt) {
    Module* mod = ctxt.module();

    for (auto&& ip: mod->inputs()) {
        auto inputName = ctxt.name(ip, true);
        auto width = bitwidth(ip->type());
        if (bitwidth(ip->type()) > 0)
            ctxt << boost::format("    input [%1%:0] %2%, //Type: %3%\n")
                    % (width - 1)
                    % inputName
                    % typestr(ip->type());
        ctxt << boost::format("    input %1%_valid,\n") % inputName;
        ctxt << boost::format("    output %1%_bp,\n") % inputName;

    }
    ctxt << "\n";
    for (auto&& op: mod->outputs()) {
        auto outputName = ctxt.name(op, true);
        auto width = bitwidth(op->type());
        if (bitwidth(op->type()) > 0)
            ctxt << boost::format("    output [%1%:0] %2%, //Type: %3%\n")
                    % (width - 1)
                    % outputName
                    % typestr(op->type());
        ctxt << boost::format("    output %1%_valid,\n") % outputName;
        ctxt << boost::format("    input %1%_bp,\n") % outputName;
    }

    ctxt << "\n"
         << "    input clk,\n"
         << "    input resetn\n"
         << ");\n\n";
    

    ConnectionDB* conns = mod->conns();
    if (conns == NULL) {
        throw InvalidArgument("Verilog synthesizer cannot operate on opaque modules!");
    }

    ctxt << "    // Input back pressure connection\n";
    for (auto&& ip: mod->inputs()) {
        OutputPort* dummyOP = mod->getDriver(ip);

        ctxt.namer().assignName(dummyOP, mod, ctxt.name(ip, true));
        ctxt << boost::format("    assign %1%_bp = \n")
                    % ctxt.name(ip, true);

        vector<InputPort*> sinks;
        conns->findSinks(dummyOP, sinks);
        for (auto ip: sinks) {
            ctxt << boost::format("        %1%_bp |\n")
                            % ctxt.name(ip);
        }
        ctxt << "        1'b0;\n";
    }
    ctxt << "\n";

    for (auto&& op: mod->outputs()) {
        InputPort* dummyIP = mod->getSink(op);
        ctxt.namer().assignName(dummyIP, mod, ctxt.name(op, true));
        OutputPort* source = conns->findSource(dummyIP);
        if (bitwidth(op->type()) > 0)
            ctxt << boost::format("    assign %1% = %2%;\n")
                        % ctxt.name(op, true)
                        % ctxt.name(source);
        ctxt << boost::format("    assign %1%_valid = %2%_valid;\n")
                    % ctxt.name(op, true)
                    % ctxt.name(source);
    }

    ctxt << "\n";
}

void VerilogSynthesizer::writeBlocks(Context& ctxt) {
    ConnectionDB* conns = ctxt.module()->conns();
    
    vector<Block*> blocks;
    ctxt.module()->blocks(blocks);
    for (Block* b: blocks) {
        if (dynamic_cast<DummyBlock*>(b) != NULL)
            continue;

        ctxt << "    // Block \"" << ctxt.primBlockName(b) << "\" type "
             << cpp_demangle(typeid(*b).name()) << "\n";
        for (InputPort* ip: b->inputs()) {
            Connection c;
            auto inpFound = conns->find(ip, c);
            std::string opName;
            if (!inpFound) {
                fprintf(stderr, "Warning: no driver found for input %s!\n", ctxt.name(ip).c_str());
                fprintf(stderr, "         input %u of %lu of block %s type %s\n",
                                b->inputNum(ip)+1, b->inputs().size(),
                                ctxt.name(b).c_str(), cpp_demangle(typeid(*b).name()).c_str());
                opName = "UNKNOWN";
            } else {
                opName = ctxt.name(c.source());
            }

            if (bitwidth(ip->type()) == 0) {
                ctxt << boost::format("    reg %1%_valid = %2%_valid;\n"
                                      "    reg %1%_bp;\n")
                            % ctxt.name(ip)
                            % opName;
            } else {
                ctxt << boost::format("    reg [%1%-1:0] %2% = %3%;\n"
                                      "    reg %2%_valid = %3%_valid;\n"
                                      "    reg %2%_bp;\n")
                            % bitwidth(ip->type())
                            % ctxt.name(ip)
                            % opName;
            }
        }

        for (OutputPort* op: b->outputs()) {

            if (bitwidth(op->type()) == 0) {
                ctxt << boost::format("    reg %1%_valid;\n"
                                      "    reg %1%_bp = \n")
                            % ctxt.name(op);
            } else {
                ctxt << boost::format("    reg [%1%-1:0] %2%;\n"
                                      "    reg %2%_valid;\n"
                                      "    reg %2%_bp = \n")
                            % bitwidth(op->type())
                            % ctxt.name(op);
            }

            vector<Connection> cVec;
            conns->find(op, cVec);
            for (Connection c: cVec) {
                ctxt << boost::format("            %1%_bp |\n")
                            % ctxt.name(c.sink());
            }
            ctxt << "            1'b0;\n";
        }

        print(ctxt, b);
        ctxt << "\n";
    }


}

void VerilogSynthesizer::print(Context& ctxt, Block* b)
{
    const vector<Printer*>& possible_printers = _printers(b);
    if (possible_printers.size() == 0) {
        auto blockName = ctxt.name(b);
        throw ImplementationError(
            str(boost::format(" Cannot translate block %1% of type %2% into verilog.") 
                            % blockName
                            % cpp_demangle(typeid(*b).name())));
    } else {
        auto printer = possible_printers.front();
        printer->print(ctxt, b);

        if (!printer->customLID()) {
            assert(!b->outputsIndependent());

            std::string joinOp;
            std::string terminator;
            switch (b->firing()) {
            case Block::AND:
                joinOp = "&";
                terminator = "1'b1";
                break;
            case Block::OR:
                joinOp = "|";
                terminator = "1'b0";
                break;
            }

            ctxt << "    wire " << ctxt.name(b) << "_valid = \n";
            for (auto ip: b->inputs()) {
                ctxt << "        " << ctxt.name(ip) << "_valid " << joinOp << "\n";
            }
            ctxt << "        " << terminator << ";\n";

            for (auto op: b->outputs()) {
                ctxt << "    assign " << ctxt.name(op) << "_valid = " << ctxt.name(b) << "_valid;\n";
            }


            ctxt << "    wire " << ctxt.name(b) << "_bp = \n";
            ctxt << "        ~" << ctxt.name(b) << "_valid | \n";
            for (auto op: b->outputs()) {
                ctxt << "        " << ctxt.name(op) << "_bp | " << "\n";
            }
            ctxt << "        1'b0;\n";

            for (auto ip: b->inputs()) {
                ctxt << "    assign " << ctxt.name(ip) << "_bp = " << ctxt.name(b) << "_bp;\n";
            }
        }
    }
}

void print_function(VerilogSynthesizer::Context& ctxt, Block* c,
                    const char* op, bool signedWrap) {
    Function* b = dynamic_cast<Function*>(c);
    ctxt << "    assign " << ctxt.name(b->dout()) << " = ";
    auto dinType = b->din()->type();
    assert(dinType->isStructTy());
    auto dinName = ctxt.name(b->din());
    bool first = true;
    for (unsigned i = 0; i < dinType->getNumContainedTypes(); i++) {
        unsigned offset = bitoffset(dinType, i);
        unsigned width = bitwidth(dinType->getContainedType(i));
        if (width == 0)
            continue;
        if (first)
            first = false;
        else
            ctxt << " " << op << " ";
        if (signedWrap)
            ctxt << boost::format("$signed(%1%[%2%:%3%])") 
                            % dinName
                            % (offset+width-1)
                            % offset;
        else 
            ctxt << boost::format("%1%[%2%:%3%]") 
                            % dinName
                            % (offset+width-1)
                            % offset;
    }
    ctxt << ";\n";
}

class PipelineRegisterPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<PipelineRegister*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        PipelineRegister* reg = dynamic_cast<PipelineRegister*>(c);
        if (reg->controller() == NULL) {
            if (bitwidth(reg->din()->type()) > 0)
                ctxt << boost::format("    `DFF(%1%, %2%, %3%, %4%_ce);\n")
                            % bitwidth(reg->din()->type())
                            % ctxt.name(reg->dout())
                            % ctxt.name(reg->din())
                            % ctxt.name(reg);
            ctxt << boost::format("    `LI_CONTROL(%1%_valid, %2%_valid, %2%_bp, %1%_bp, %3%_ce);\n")
                        % ctxt.name(reg->dout())
                        % ctxt.name(reg->din())
                        % ctxt.name(reg);
        } else {
            assert(false && "No support for shared controllers yet");
        }
    }

    virtual bool customLID() const {
        return true;
    }
};

template<typename BlockType>
class BinaryOpPrinter : public VerilogSynthesizer::Printer {
    const char* _op;
public:
    BinaryOpPrinter(const char* op) : _op(op) { }

    bool handles(Block* b) const {
        return dynamic_cast<BlockType*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        bool signedWrap = false;
        if (IntDivide* id = dynamic_cast<IntDivide*>(c))
            signedWrap = id->isSigned();
        if (IntRemainder* ir = dynamic_cast<IntRemainder*>(c))
            signedWrap = ir->isSigned();
        print_function(ctxt, c, _op, signedWrap);
    }
};

class CompareOpPrinter : public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<IntCompare*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        const char* op = NULL;
        IntCompare* b = dynamic_cast<IntCompare*>(c);

        switch (b->op()) {
        case IntCompare::EQ:
            op = "==";
            break;
        case IntCompare::NEQ:
            op = "!=";
            break;
        case IntCompare::GT:
            op = ">";
            break;
        case IntCompare::GTE:
            op = ">=";
            break;
        }
        print_function(ctxt, c, op, b->isSigned());
    }
};

class BitwiseOpPrinter : public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Bitwise*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        const char* op = NULL;
        Bitwise* b = dynamic_cast<Bitwise*>(c);
        switch (b->op()) {
        case Bitwise::AND:
            op = "&";
            break;
        case Bitwise::OR:
            op = "|";
            break;
        case Bitwise::XOR:
            op = "^";
            break;
        }
        print_function(ctxt, c, op, false);
    }
};

class IntTruncatePrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<IntTruncate*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Function* f = dynamic_cast<Function*>(c);
        ctxt << "    assign " << ctxt.name(f->dout()) << " = "
             << boost::format("%1%[%2%:0];\n")
                            % ctxt.name(f->din())
                            % (bitwidth(f->dout()->type()) - 1);
    }
};

class IntExtendPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<IntExtend*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        IntExtend* f = dynamic_cast<IntExtend*>(c);
        unsigned ib = bitwidth(f->din()->type());
        unsigned ob = bitwidth(f->dout()->type());
        assert(ob > ib);
        string msb = str(boost::format("%1%[%2]")
                            % ctxt.name(f->din())
                            % (ib - 1));
        ctxt << "    assign " << ctxt.name(f->dout()) << " = { "
             << boost::format("{%1%{%2%}}")
                % (ob - ib)
                % ( f->signExtend() ? msb : "1'b0")
             << ", " << ctxt.name(f->din()) << "};\n";
    }
};

template<typename Op>
class IdentityOpPrinter : public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Op*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Op* f = dynamic_cast<Op*>(c);
        if (bitwidth(f->din()->type()) > 0)
            ctxt << "    assign " << ctxt.name(f->dout()) << " = "
                 << ctxt.name(f->din()) << ";\n";
    }
};

class ConstantPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Constant*>(b) != NULL;
    }

    static std::string toString(llvm::Constant* c) {
        switch (c->getType()->getTypeID()) {
            case llvm::Type::IntegerTyID:
                return str(boost::format("%1%'d%2%\n") 
                            % bitwidth(c->getType())
                            % llvm::dyn_cast<llvm::ConstantInt>(c)->
                                    getValue().toString(10, true));
            case llvm::Type::PointerTyID:
                assert(c->isNullValue());
                return str(boost::format("%1%'h%2%\n") 
                            % bitwidth(c->getType())
                            % 0);
        default:
            throw InvalidArgument("Constant type not yet supported");
        }
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Constant* f = dynamic_cast<Constant*>(c);
        if (bitwidth(f->dout()->type()) > 0)
            ctxt << "    assign " << ctxt.name(f->dout()) << " = "
                 << toString(f->value()) << ";";
    }
};

class JoinPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Join*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Join* j = dynamic_cast<Join*>(c);
        if (bitwidth(j->dout()->type()) == 0)
            return;
        ctxt << "    assign " << ctxt.name(j->dout()) << " = { ";
        bool first = true;
        for (signed i = j->din_size() - 1; i >= 0; i--) {
            if (bitwidth(j->din(i)->type()) == 0)
                continue;
            if (first)
                first = false;
            else
                ctxt << ", ";
            ctxt << ctxt.name(j->din(i));
        }
        ctxt << " };\n";
    }
};

class SplitPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Split*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Split* s = dynamic_cast<Split*>(c);
        auto dinName = ctxt.name(s->din());
        for (unsigned i=0; i < s->dout_size(); i++) {
            if (bitwidth(s->dout(i)->type()) == 0)
                continue;
            unsigned offset = bitoffset(s->din()->type(), i);
            unsigned width = bitwidth(s->din()->type()->getContainedType(i));
            ctxt << "    assign " << ctxt.name(s->dout(i)) << " = "
                 << boost::format("%1%[%2%:%3%];\n") 
                        % dinName
                        % (offset+width-1)
                        % offset;
        }
    }
};

class ExtractPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Extract*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Extract* e = dynamic_cast<Extract*>(c);
        auto dinName = ctxt.name(e->din());
        unsigned offset = 0; 
        llvm::Type* type = e->din()->type();
        for (unsigned i: e->path()) {
            offset += bitoffset(type, i);
            type = type->getContainedType(i);
        }

        unsigned width = bitwidth(e->dout()->type());

        ctxt << "    assign " << ctxt.name(e->dout()) << " = "
             << boost::format("%1%[%2%:%3%];\n") 
                    % dinName
                    % (offset+width-1)
                    % offset;
    }
};

class MultiplexerPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Multiplexer*>(b) != NULL;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Multiplexer* m = dynamic_cast<Multiplexer*>(c);
        auto doutName = ctxt.name(m->dout());
        auto dinType = m->din()->type();
        auto dinName = ctxt.name(m->din());
        unsigned nWidth = bitwidth(dinType->getContainedType(0));
        unsigned nOffset = bitoffset(dinType, 0);

        ctxt << "    always\n"
             << "    begin\n"
             << boost::format("        case (%1%[%2%:%3%])\n") 
                    % dinName
                    % (nWidth + nOffset - 1)
                    % nOffset;
        for (size_t i=1; i<dinType->getNumContainedTypes(); i++) {
            auto offset = bitoffset(dinType, i);
            ctxt << boost::format("            %1% : %2% = %3%[%4%:%5%];\n")
                        % (i - 1)
                        % doutName
                        % dinName
                        % (offset + bitwidth(dinType->getContainedType(i)) - 1)
                        % offset;
        }
        ctxt << "        endcase\n"
             << "    end\n";
    }
};

class RouterPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Router*>(b) != NULL;
    }

    virtual bool customLID() const {
        return true;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Router* r = dynamic_cast<Router*>(c);
        auto dinName = ctxt.name(r->din());
        auto dinType = r->din()->type()->getContainedType(1);
        auto dinOffset = bitoffset(r->din()->type(), 1);
        auto dinWidth = bitwidth(dinType);

        auto selType = r->din()->type()->getContainedType(0);
        auto selWidth = bitwidth(selType);
        auto selOffset = bitoffset(r->din()->type(), 0);

        for (unsigned i=0; i<r->dout_size(); i++) {
            auto op = r->dout(i);
            ctxt << boost::format("    assign %8% = (%1%[%2%:%3%] == %4%) ? %1%[%5%:%6%] : {%7%{1'bx}};\n"
                                  "    assign %8%_valid = (%1%[%2%:%3%] == %4%) ? %1%_valid : 1'b0;\n")
                    % dinName
                    % (selWidth + selOffset - 1)
                    % selOffset
                    % i
                    % (dinWidth + dinOffset - 1)
                    % dinOffset
                    % dinWidth
                    % ctxt.name(op);
        }
        ctxt << "    assign " << dinName << "_bp = \n";
        for (unsigned i=0; i<r->dout_size(); i++) {
            auto op = r->dout(i);
            ctxt << boost::format("        (%1%_bp & %1%_valid) |\n")
                        % ctxt.name(op);
        }
        ctxt << "        1'b0;\n";
    }
};

class SelectPrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<Select*>(b) != NULL;
    }

    virtual bool customLID() const {
        return true;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* c) const {
        Select* s = dynamic_cast<Select*>(c);
        std::string style = "LLPM_Select_Priority";
    
        ctxt << boost::format("    wire [%1%:0] %2%_input_combined [%3%:0];\n") 
                            % (bitwidth(s->dout()->type()) - 1)
                            % ctxt.name(s)
                            % (s->din_size() - 1)
             << boost::format("    wire %1%_valids[%2%:0];\n") 
                            % ctxt.name(s)
                            % (s->din_size() - 1)
             << boost::format("    wire %1%_bp[%2%:0];\n") 
                            % ctxt.name(s)
                            % (s->din_size() - 1)
            ;
        for (unsigned i=0; i<s->din_size(); i++) {
            ctxt << boost::format("    assign %1%_input_combined[%2%] = %3%;\n")
                            % ctxt.name(s)
                            % i
                            % ctxt.name(s->din(i))
                 << boost::format("    assign %1%_valids[%2%] = %3%_valid;\n")
                            % ctxt.name(s)
                            % i
                            % ctxt.name(s->din(i))
#if 0
                 << boost::format("    assign %3%_bp = %1%_bp[%2%];\n")
                            % ctxt.name(s)
                            % i
                            % ctxt.name(s->din(i))
#endif
                ;
        }

        ctxt << boost::format("    %1% # (\n") % style
             << boost::format("        .Width(%1%),\n") % bitwidth(s->dout()->type())
             << boost::format("        .NumInputs(%1%), \n") % s->din_size()
             << boost::format("        .CLog2NumInputs(%1%)\n") 
                        % std::max((unsigned)1, (unsigned)ceil(log2(s->din_size())))
             << boost::format("    ) %1% (\n") % ctxt.name(c)
             <<               "        .clk(clk),\n"
             <<               "        .resetn(resetn),\n"

             << boost::format("        .x(%1%_input_combined), \n") % ctxt.name(s)
             << boost::format("        .x_valid(%1%_valids), \n") % ctxt.name(s)
             << boost::format("        .x_bp(%1%_bp), \n") % ctxt.name(s)

             << boost::format("        .a(%1%), \n") % ctxt.name(s->dout())
             << boost::format("        .a_valid(%1%_valid), \n") % ctxt.name(s->dout())
             << boost::format("        .a_bp(%1%_bp) \n") % ctxt.name(s->dout())
             <<               "    );\n"
             ;

        for (unsigned i=0; i<s->din_size(); i++) {

                 ctxt << boost::format("    assign %3%_bp = %1%_bp[%2%];\n")
                            % ctxt.name(s)
                            % i
                            % ctxt.name(s->din(i))
                ;
        }
    }
};

struct AttributePrinter {
    template<typename T>
    void print(VerilogSynthesizer::Context& ctxt,
               string k, T t, bool last = false) {
        ctxt << boost::format("        .%1%(%2%)%3%\n")
                    % k
                    % t
                    % (last ? "" : ",");
    }

};



template<typename BType, typename Attrs>
class VModulePrinter: public VerilogSynthesizer::Printer {
public:
    bool handles(Block* b) const {
        return dynamic_cast<BType*>(b) != NULL;
    }

    virtual bool customLID() const {
        return true;
    }

    void print(VerilogSynthesizer::Context& ctxt, Block* b) const {
        BType* mod = dynamic_cast<BType*>(b);
        assert(mod != NULL);

        Attrs a;
        ctxt << "    " << a.name(mod) << " # ( \n";
        a(ctxt, mod);
        ctxt << "    ) " << ctxt.name(mod) << " (\n";

        for (InputPort* ip: mod->inputs()) {
            if (bitwidth(ip->type()) > 0)
                ctxt << boost::format("        .%1%(%2%),\n")
                        % ctxt.name(ip, true)
                        % ctxt.name(ip);
            ctxt << boost::format("        .%1%_valid(%2%_valid),\n"
                                  "        .%1%_bp(%2%_bp),\n")
                    % ctxt.name(ip, true)
                    % ctxt.name(ip);
        }

        for (OutputPort* op: mod->outputs()) {
            if (bitwidth(op->type()) > 0)
                ctxt << boost::format("        .%1%(%2%),\n")
                        % ctxt.name(op, true)
                        % ctxt.name(op);
            ctxt << boost::format("        .%1%_valid(%2%_valid),\n"
                                  "        .%1%_bp(%2%_bp),\n")
                    % ctxt.name(op, true)
                    % ctxt.name(op);
        }

        ctxt << "        .clk(clk),\n"
             << "        .resetn(resetn)\n";

        ctxt << "    );\n";
    }
};

struct ModulePrinter : public AttributePrinter {
    std::string name(Module* m) {
        return m->name();
    }
    void operator()(VerilogSynthesizer::Context& ctxt, Block* b) { }
};

struct RTLRegAttr : public AttributePrinter {
    std::string name(Block* b) {
        return "RTLReg";
    }
    void operator()(VerilogSynthesizer::Context& ctxt, RTLReg* r) {
        print(ctxt, "Width", bitwidth(r->type()), true);
    }
};

void VerilogSynthesizer::addDefaultPrinters() {
    _printers.appendEntry(new BinaryOpPrinter<IntAddition>("+"));
    _printers.appendEntry(new BinaryOpPrinter<IntSubtraction>("-"));
    _printers.appendEntry(new BinaryOpPrinter<IntMultiply>("*"));
    _printers.appendEntry(new BinaryOpPrinter<IntDivide>("/"));
    _printers.appendEntry(new BinaryOpPrinter<IntRemainder>("%"));

    _printers.appendEntry(new CompareOpPrinter());
    _printers.appendEntry(new BitwiseOpPrinter());

    _printers.appendEntry(new IntTruncatePrinter());
    _printers.appendEntry(new IntExtendPrinter());

    _printers.appendEntry(new IdentityOpPrinter<Identity>());
    _printers.appendEntry(new IdentityOpPrinter<Cast>());
    _printers.appendEntry(new IdentityOpPrinter<Wait>());

    _printers.appendEntry(new ConstantPrinter());

    _printers.appendEntry(new JoinPrinter());
    _printers.appendEntry(new SelectPrinter());
    _printers.appendEntry(new SplitPrinter());
    _printers.appendEntry(new ExtractPrinter());

    _printers.appendEntry(new PipelineRegisterPrinter());

    _printers.appendEntry(new MultiplexerPrinter());
    _printers.appendEntry(new RouterPrinter());

    _printers.appendEntry(new VModulePrinter<RTLReg, RTLRegAttr>());
    _printers.appendEntry(new VModulePrinter<Module, ModulePrinter>());
}

bool VerilogSynthesizer::blockIsPrimitive(Block* b) {
    return primitiveStops()->stopRefine(b);
}

} // namespace llpm
